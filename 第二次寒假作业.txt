第二次作业
专题一：串。密码脱落
X星球的考古学家发现了一批古代留下来的密码。
这些密码是由A、B、C、D 四种植物的种子串成的序列。
仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。  ABA  ABBA   A由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。你的任务是：
给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。
输入一行，表示现在看到的密码串（长度不大于1000）
要求输出一个正整数，表示至少脱落了多少个种子。
例如，输入：
ABCBA
则程序应该输出：
0
再例如，输入：
CBABCDCDCBABC
则程序应该输出：
3
----------------------
思路
A............C
****A
C****
常规思路，当然是从两边进行比较字符是否相等，不相等则说明脱落了一个，每次取从左面或者从右面开始脱落数最小的一个，采用递归写法。直接递归复杂度很高，于是采用网上看到的，也的确是比较常用的用数组存储中间状态值的方法，也就相当于动态规划。复杂度有明显的下降。
#include <stdio.h>
#include<string.h>
#define maxx 1000
int map[maxx][maxx];
char s[maxx];
int dp(int dl,int dr)
{
    if(dl>=dr)
        return 0;
    if(map[dl][dr]>=0)
        return map[dl][dr];
    if(s[dl]==s[dr])//两端相同
    {
        map[dl][dr]=dp(dl+1,dr-1);
        return map[dl][dr];
    }
    else
    {
        map[dl][dr]=dp(dl+1,dr);//从左面开始递归求解
        int c=0;
        c=dp(dl,dr-1);//从右面开始递归求解
        if(c<map[dl][dr])//取最小的
            map[dl][dr]=c;
        map[dl][dr]++;
        return map[dl][dr];
    }
}
int main()
{
    gets(s);
    int n=strlen(s);
    int i,j;
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
        map[i][j]=-1;
    dp(0,n-1);
    printf("%d",map[0][n-1]);
    printf("\n");
    return 0;
}

专题二：递归
1、39级台阶，
1. 每步1或2阶
2. 必须是偶数步 
求上台阶的方案数。
------------------
没有偶数限制：
f(n) = f(n-1) + f(n-2)  
--------------------
经典的间接递归的例子：
f(n)  必须偶数步
g(n)  必须奇数步
f(n) = g(n-1) + g(n-2)
g(n) = f(n-1) + f(n-2)
出口：
f(n)  n==0: 1   n==1: 0  n==2: 1
g(n)  n==0: 0   n==1: 1  n==2: 1
题目描述的特别清楚了，照着写一下代码即可。间接递归
#include <stdio.h>
int g(int n);
int f(int n)
{
    if(n==0)
        return 1;
    if(n==1)
        return 0;
    if(n==2)
        return 1;
    else
        return g(n-1)+g(n-2);
}
int g(int n)
{
    if(n==0)
        return 0;
    if(n==1)
        return 1;
    if(n==2)
        return 1;
    else
        return f(n-1)+f(n-2);
}
int main()
{
    printf("%d\n",f(39));
    return 0;
}

2、搭积木
小明最近喜欢搭数字积木，
一共有10块积木，每个积木上有一个数字，0~9。
搭积木规则：
每个积木放到其它两个积木的上面，并且一定比下面的两个积木数字小。
最后搭成4层的金字塔形，必须用完所有的积木。
下面是两种合格的搭法：
   0
  1 2
 3 4 5
6 7 8 9
   0
  3 1
 7 5 2
9 8 6 4    
请你计算这样的搭法一共有多少种？
请填表示总数目的数字。
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。
要求每个积木上的数字必须小于它下方的两个积木数字，即若上方积木数字大于下方任何一个，即不满足条件。定义一个judge函数进行判断是否满足条件。将0到9十个数字进行全排列，进行判断。
关于全排列，好久前从某个地方发现了next_permutation(a,a+n)这个函数，基本上便一直用这个了，现在有个疑惑是比赛的时候可不可以用这个方便的函数，希望学长解答。
它是在C++的标准函数库STL中的函数，我觉得应该是可以的吧。
#include <iostream>
#include <algorithm>
using namespace std;

int cnt;//计数
int a[10]= {0,1,2,3,4,5,6,7,8,9};
bool judge()
{    
if(a[0]>a[1]||a[0]>a[2]||a[1]>a[3]||a[1]>a[4]||a[2]>a[4]||a[2]>a[5]||a[3]>a[6]||a[3]>a[7]||a[4]>a[7]||a[4]>a[8]||a[5]>a[8]||a[5]>a[9])
        return false;
    else
        return true;
}
int main()
{
    do
    {
        if(judge())
            cnt++;
    }
    while(next_permutation(a,a+10));
    cout<<cnt;
    return 0;
}

3、取球博弈
两个人玩取球的游戏。
一共有N个球，每人轮流取球，每次可取集合{n1,n2,n3}中的任何一个数目。
如果无法继续取球，则游戏结束。
此时，持有奇数个球的一方获胜。
如果两人都是奇数，则为平局。
假设双方都采用最聪明的取法，
第一个取球的人一定能赢吗？
试编程解决这个问题。
输入格式：
第一行3个正整数n1 n2 n3，空格分开，表示每次可取的数目 (0<n1,n2,n3<100)
第二行5个正整数x1 x2 ... x5，空格分开，表示5局的初始球数(0<xi<1000)
输出格式：
一行5个字符，空格分开。分别表示每局先取球的人能否获胜。
能获胜则输出+，
次之，如有办法逼平对手，输出0，
无论如何都会输，则输出-
例如，输入：
1 2 3
1 2 3 4 5
程序应该输出：
+ 0 + 0 -
再例如，输入：
1 4 5
10 11 12 13 15
程序应该输出：
0 - 0 + +
再例如，输入：
2 3 5
7 8 9 10 11
程序应该输出：
+ 0 0 0 0
-------------------------------------
平局？
f(局面 x)
{
   if(简单局面) return ...
   逼平 = false;
   for( 所有可能的走法 ) {
      本次走法 x --> y
      if(f(y)==输) return 赢
      if(f(y)==平局)逼平 = true;
   }
   if(逼平) return 平局
   return 输
}
根据上面思路，写f函数，若是简单局面，即当前不能再取球，直接判断胜负即可。
然后设立一个变量flag标志是否可以平局。
只有对方取球或者自己取球这两种情况，都是若对方输，则自己胜。或者为平局。
题目意思不能胜的话，能平则平，否则才输。
#include <stdio.h>
#include <algorithm>
using namespace std;
int a[3];
int f(int rest,int mnum,int hnum,int z)//rest当前的球数,mynum我的球数 hisnum他的球数
{
    if(rest<a[0])//不能再取球，直接判断胜败
    {
        if(mnum%2==0&&hnum%2==1)//自己的为偶数，对手的是奇数，胜！
            return 1;
        else if(mnum%2==1&&hnum%2==0)//自己的为奇数，对手的为偶数，败！
            return -1;
        else//全奇或者全偶，平局
            return 0;
    }
    bool flag=false;//是否可以平局
    if(z%2==0)
        for(int i=0; i<3; i++)
        {
            if(rest>=a[i])
            {
                if(f(rest-a[i],mnum+a[i],hnum,(z+1)%2)==-1)
                    return 1;
                if(f(rest-a[i],mnum+a[i],hnum,(z+1)%2)==0)
                    flag=true;
            }
        }
    if(z%2==1)
        for(int i=0; i<3; i++)
        {
            if(rest>=a[i])
            {
                if(f(rest-a[i],mnum,hnum+a[i],(z+1)%2)==-1)
                    return 1;
                if(f(rest-a[i],mnum,hnum+a[i],(z+1)%2)==0)
                    flag=true;
            }
        }
    if(flag)//能平则平
        return 0;
    else
        return -1;

}
int main()
{
    scanf("%d %d %d",&a[0],&a[1],&a[2]);
    sort(a,a+3);
    int b[5];
    for(int i=0; i<5; i++)
        scanf("%d",&b[i]);
    for(int i=0; i<5; i++)
    {
        if(f(b[i],0,0,0)==0)
            printf("0");
        else if(f(b[i],0,0,0)==1)
            printf("+");
        else if(f(b[i],0,0,0)==-1)
            printf("-");
    }
    return 0;
}

代码有些问题，数据不能全过。。。。
4、 今盒子里有n个小球，A、B两人轮流从盒中取球，每个人都可以看到另一个人取了多少个，也可以看到盒中还剩下多少个，并且两人都很聪明，不会做出错误的判断。
    我们约定：
  每个人从盒子中取出的球的数目必须是：1，3，7或者8个。
    轮到某一方取球时不能弃权！
    A先取球，然后双方交替取球，直到取完。
    被迫拿到最后一个球的一方为负方（输方）
    请编程确定出在双方都不判断失误的情况下，对于特定的初始球数，A是否能赢？
    程序运行时，从标准输入获得数据，其格式如下：
    先是一个整数n(n<100)，表示接下来有n个整数。然后是n个整数，每个占一行（整数<10000），表示初始球数。
    程序则输出n行，表示A的输赢情况（输为0，赢为1）。
    例如，用户输入：
４
１
２
10
18
    则程序应该输出：
0
1
1
0
    注意：
    请仔细调试！您的程序只有能运行出正确结果的时候才有机会得分！
     在评卷时使用的输入数据与试卷中给出的实例数据可能是不同的。
每个人的选择有1,3,7,8四种，用一个数组存起来。然后进行遍历，当剩下一个的时候则自己必输。
#include <stdio.h>
int a[4]={1,3,7,8};
int fx(int n)
{
    int i;
    for(i=0;i<4;i++)//遍历所有可能情况
    {
        if(n>a[i])
            if(fx(n-a[i])==0)//对方输，自己赢
            return 1;
    }
    return 0;//输
}
int main()
{
    int n;
    scanf("%d",&n);
    int b[100];
    int i;
    for(i=0;i<n;i++)
        scanf("%d",&b[i]);
    for(i=0;i<n;i++)
    printf("%d\n",fx(b[i]));
    return 0;
}


5、【编程题】
    这是一个纵横火柴棒游戏。如图[1.jpg]，在一个3x4的方格中，游戏的双方轮流放置火柴棒。其规则是：
    1. 不能放置在已经放置火柴棒的地方（即只能在空格中放置）。
    2. 火柴棒的方向只能是垂直或水平放置。
    3. 火柴棒不能与其它格子中的火柴“连通”。所谓连通是指两根火柴棒可以连成一条直线，且中间没有其它不同方向的火柴“阻拦”。
    例如：图[1.jpg]所示的局面下，可以在C2位置竖直放置，但不能水平放置，因为会与A2连通。同样道理，B2，B3，D2此时两种方向都不可以放置。但如果C2竖直放置后，D2就可以水平放置了，因为不再会与A2连通（受到了C2的阻挡）。
    4. 游戏双方轮流放置火柴，不可以弃权，也不可以放多根。直到某一方无法继续放置，则该方为负（输的一方）。
    游戏开始时可能已经放置了多根火柴。
    你的任务是：编写程序，读入初始状态，计算出对自己最有利的放置方法并输出。
    如图[1.jpg]的局面表示为：
00-1
-000
0100
    即用“0”表示空格位置，用“1”表示竖直放置，用“-”表示水平放置。
【输入、输出格式要求】
     用户先输入整数 n(n<100), 表示接下来输入 n 种初始局面，每种局面占3行(多个局面间没有空行)。
    程序则输出对应的每种初始局面，计算出的最佳走法（行号+列号+放置方式）。
    例如：用户输入：
2
0111
-000
-000
1111
----
0010
   则程序可以输出：
00-
211
   输出结果的含义为：
    对第一个局面，在第0行第0列水平放置
     对第二个局面，在第2行第1列垂直放置
   注意：
     行号、列号都是从0开始计数的。
        对每种局面可能有多个最佳放置方法（解不唯一），只输出一种即可。
   例如，对第一个局面，001 也是正解；最第二个局面，201也是正解。

6、标题：高僧斗法
    古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。
    节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。(如图1所示)
    两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越 过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。
    两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。
    对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。
    输入数据为一行用空格分开的N个整数，表示小和尚的位置。台阶序号从1算起，所以最后一个小和尚的位置即是台阶的总数。（N<100, 台阶总数<1000）
      输出为一行用空格分开的两个整数: A B, 表示把A位置的小和尚移动到B位置。若有多个解，输出A值较小的解，若无解则输出-1。
例如：
用户输入：
1 5 9
则程序输出：
1 4
再如：
用户输入：
1 5 8 10
则程序输出：
1 3
资源约定：
峰值内存消耗 < 64M
CPU消耗  < 1000ms
请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。
所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。
注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。
提交时，注意选择所期望的编译器类型(千万不要混淆c和cpp)。
    
解题锦囊：所有这类的博弈问题都可以归结为尼姆游戏。
这里考虑：如何把本问题转化为尼姆游戏问题。
两两连续分在一组：
若偶数
(a1 a2) (b1 b2)
若奇数
(a1 a2) (b1 b2) (x |)
考虑每个组的间隔，可以转化为尼姆问题。
测试用例我发到群里。
在上一次遇到取石子问题的威左夫博弈问题时，曾一起了解过巴什博弈和尼姆博奕，一开始看到这是尼姆博奕想着应该挺简单，不过如何转换确实挺难的，还是没忍住了去上了百度，看了看网上的代码思路和写法。。。
#include <iostream>
#include <stdio.h>
using namespace std;
int a[1010];

int main()
{
    int k;
    char c;
    int t=0;
    while(1)
    {
        scanf("%d%c",&k,&c);
        a[++t]=k;
        if(c=='\n')
            break;
    }
    k=0;
    int ans=0;
    //每两个相邻的为一堆，转化为尼姆
    while(2*k+2<=t)
    {
        ans^=(a[2*k+2]-a[2*k+1]-1);//进行异或操作
        k++;
    }
    if(ans==0)
        cout<<"-1"<<endl;
    else{
            for(int i=1;i<t;i++){//每个小和尚
            for(int j=a[i]+1;j<a[i+1];j++)//每个小和尚可以走的位置
            {
                k=a[i];//初始状态
                a[i]=j;//尝试走
                int ans=0;
                for(int l=2;l<=t;l+=2)
ans^=(a[l]-a[l-1]-1);//进行异或操作，如果结果为0，将这个局面给自己，自己就可以赢
            if (ans==0){
                    cout<<k<<" "<<j<<endl;
                    break;
                }
                a[i]=k;  //回到原来的状态
            }
        }
    }
    return 0;
}
